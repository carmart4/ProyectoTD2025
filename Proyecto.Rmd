---
title: "Análisis de Tickets de Supermercado: Mini Proyecto 2025"
author: |
  <center>
  Ferrer Font, Neus<br>
  Navarro García, Marta<br>
  Rodríguez Simón, Alba<br>
  Aissa Djellouli, Mohammed<br>
  Balbastre Aparisi, Héctor<br>
  Ruiz Ripoll, Joan<br>
  Martinez Torres, Carlos Santiago
  </center>
date: "`r Sys.Date()`"
output:
  html_document:
    echo: true
    number_sections: true
    theme: lumen
    toc: true
  bookdown::pdf_document2:
    toc: true
    toc_depth: 3
    number_sections: true
    figure_caption: "Figura" # Referencias en castellano
    table_caption: "Tabla"
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
  html_notebook:
    echo: true
    number_sections: true
    toc: true
  pdf_document: default
  bookdown::html_document2:
    echo: true
    number_sections: true
    theme: spacelab
    toc: true
    figure_caption: "Figura"
    table_caption: "Tabla"
always_allow_html: true
params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"
subtitle: "Tratamiento de datos. Grado en Ciencia de Datos - UV"
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---

```{r}
# Limpiamos el entorno.
rm(list = ls())
```

# Lo que necesitamos para trabajar. 

Importacion de las librerias. 
```{r, warning=FALSE, message=FALSE, eval=FAlSE, results='hide'}
# Lista de paquetes que se van a utilizar
paquetes <- c("pdftools", "dplyr", "stringr", "dplyr", "ggplot2", "tidyverse")

# Función 
instalar_y_cargar <- function(paquetes) {
  nuevos <- paquetes[!(paquetes %in% installed.packages()[,"Package"])]

  if(length(nuevos) != 0) {
    install.packages(nuevos)
    }

  lapply(paquetes, library, character.only = TRUE)
}

instalar_y_cargar(paquetes)
```

# Como vamos a almacenar la informacion? Que informacion queremos almacenar? 

```{r}
# Dataframe que contendrá el nombre del fichero leido y la factura a la que pertenece. En caso de no ser leido, porque no pertenece a Mercadona, identificaremos cual fichero ha sido y lo almacenaremos en otro df.

FicheroLeido <- data.frame( FacturaFichero = character(),
                        NombreFichero = character(),
                        stringsAsFactors = FALSE
                        )

NoLeido <- data.frame( NombreFichero = character(),
                        stringsAsFactors = FALSE
                        )


# Dataframe que contendrá la información de las diferentes tiendas de las facturas.  
# Dado que no vamos a hacer operaciones con el id, CP o telefono, estas variables las guardaremos como char. 

Tienda <- data.frame( IdTienda = character(),
                      Direccion = character(),
                      CodigoPostal = character(),
                      Municipio = character(),
                      Telefono = character(),
                      stringsAsFactors = FALSE
) 

# Dataframe que contendra la informacion de las compras realizadas. 

# En principio, todo irá en character. Cuando estén todos los datos, se hara la limpieza sobre el df. 

Compra <- data.frame( Fecha = character(),
                      IdTienda = character(),
                      IdFactura = character(),
                      Producto = character(),
                      Cantidad = character(),
                      PrecioUnitario = character(),
                      Importe = character(),
                      TipoProducto = character(),
                      Parking = logical(), 
                      stringsAsFactors = FALSE
) 

```

# Carga de ficheros

```{r}
# Ficheros a trabajar 
#lista_ficheros <- list.files(path = 'data/', pattern = "\\.pdf$")
lista_nombres_ficheros <- list.files(path = 'data/')
length(lista_nombres_ficheros)
```

Hay un total de 355 ficheros, pero solo trabajaremos con los que tengan el formato correcto de Mercadona.

# Funcion EsMercadona, que comprueba si la factura es de Mercadona o no
```{r}
# Funcion para comprobar si es factura de mercadona.

# Dado que solo se puede devolver un objeto, vamos a devolver una lista con:
# valor booleano y los valores leidos. 

EsMercadona <- function(NombrePDF){
  
  carpeta <- 'data/'
  fichero <- paste0(carpeta, NombrePDF)
  
  texto <- pdf_text(fichero) # Extrae el texto del pdf.
  #texto_corregido <- iconv(texto, from = "latin1", to = "UTF-8") # Corregimos el error para valores extraños. 
  lineas <- strsplit(texto, "\n")[[1]] # Divide el texto en diferentes lineas, por cada salto de linea.
  lineas <- trimws(lineas) # Elimina espacios en blanco al inicio y final de cada linea.
  
  # Para verificar que es de Mercadona y que se ha leido correctamente la factura, vamos a evaluar la primera linea.
  
  Mercadona <- grepl('MERCADONA', lineas[1])  # Valor bool para saber si es de Mercadona o no. 
  CIF <- grepl('A-46103834', lineas[1])
  
  if ((!Mercadona) | (!CIF)){
    Mercadona <- FALSE
    lineas <- list()
  } 
  
  informacion <- list(Mercadona, lineas)
  
  # Del fichero leido, devulve si es o no de Mercadona, y las lineas leidas.
  # En caso de no ser de Mercadona, la lista de lineas es vacia. 
  return(informacion)
}

```

# Funcion que almacena la informacion de todas las tiendas leidas. 

```{r}
ExtraeEncabezado <- function(lineas) {
  
    # Obtenemos el rango de filas que contienen el encabezado

    info_compra <- grep(x=lineas, pattern='MERCADONA')[1]
    info_compra_final <- grep(x=lineas, pattern='FACTURA')[1]
  
    # Definimos el encabezado
    encabezado <- lineas[info_compra:info_compra_final]
    
    # Extraemos la informacion
    direccion <- encabezado[2]

    # Ubicacion (CP y municipio)
    ubicacion <- strsplit(encabezado[3], split = ' ')[[1]] 
    
    CP <- ubicacion[1]
    
    municipio <- ubicacion[2]
    
    telefono <- strsplit(encabezado[4], split = ': ')[[1]][2]
    
    tiempo <- strsplit(encabezado[5], split = ' ')[[1]][1:2]
    
    fecha <- tiempo[1] # String de la fecha en formato dd/mm/aaaa
    
    hora <- tiempo[2]
    
    factura <- strsplit(encabezado[6], split = ": ")[[1]]
    factura <- strsplit(factura[2], split = "-")[[1]]
    
    id_tienda <- factura[1]
    
    n_caja <- factura[2]
    
    id_factura <- factura[3]
    
    valores <- list(direccion, CP, municipio, telefono, fecha, hora, id_tienda, n_caja, id_factura)
    
    return(valores)
}
```

# Funcion que almacena:

El nombre de los ficheros que son de Mercadona, y lo que no. 2 dataframes

La información de las tiendas. 1 dataframe

```{r}
# Funcion para almacenar los ficheros leidos y los que no. 

# Le paso el dataframe de los ficheros leidos y no leidos para que los modifique, 
# si se añade un nuevo fichero. 

RegistroFicheros <- function(Nombrepdf, DF_ficheros_noleidos, DF_ficheros_leidos, Tienda_leida) {
  
  verifica <- EsMercadona(Nombrepdf)
  
  if ((verifica[[1]] == FALSE) && !(Nombrepdf %in% DF_ficheros_noleidos$NombreFichero)) {
    DF_ficheros_noleidos <- DF_ficheros_noleidos %>%
      add_row( NombreFichero = Nombrepdf )
  }
  
  else if (verifica[[1]] == TRUE) {
    
    lineas <- verifica[[2]]
    
    informacion <- ExtraeEncabezado(lineas)
    
    id_factura <- informacion[[9]]
    id_tienda <- informacion[[7]]
    
    if (!id_factura %in% DF_ficheros_leidos$FacturaFichero){
      
      DF_ficheros_leidos <- DF_ficheros_leidos %>%
                add_row(
                  FacturaFichero = id_factura,
                  NombreFichero = Nombrepdf
                )
    }
    
    if (!id_tienda %in% Tienda_leida$IdTienda){
          Tienda_leida <- Tienda_leida %>%
                        dplyr::add_row(
                          IdTienda = informacion[[7]],
                          Direccion = informacion[[1]],
                          CodigoPostal = informacion[[2]],
                          Municipio = informacion[[3]],
                          Telefono = informacion[[4]]
    )
    }
  }
  
  valores <- list(NoLeido = DF_ficheros_noleidos, FicheroLeido = DF_ficheros_leidos, TiendaLeida = Tienda_leida)
  # Devuelve los dataframes con los ficheros que han sido leidos y los que no.
  return(valores)
}

```

# Verificacion de las funciones anteriores para todos los ficheros

Cada nombre de pdf que está en la lista de los archivos leidos de la carpeta data, se registra en un dataframe. 
Es decir, si es de Mercadona almacena el nombre en el df FicheroLeido y si no, lo deja en el df NoLeido.
Esto servirá para comprobar si hay valores repetidos y/o por qué x fichero no fue leido. 

```{r}
for (f in lista_nombres_ficheros) {
  resultado <- RegistroFicheros(f, NoLeido, FicheroLeido, Tienda)
  NoLeido <- resultado$NoLeido
  FicheroLeido <- resultado$FicheroLeido
  Tienda <- resultado$TiendaLeida
}

```

Una vez que recuperamos la informacion sobre las facturas leidas y no leias, verificamos

```{r}
lista_f_almacenados <- c(NoLeido$NombreFichero, FicheroLeido$NombreFichero)
diferencia <- setdiff(lista_nombres_ficheros, lista_f_almacenados)
#diferencia

```
De estos nombres, identificamos que se trata de ficheros repetidos. Ya fueron leidos anteriormente y por tanto, no se vuelven a leer ni almacenar. El caso del 'ticket3.pdf' es un caso especial, ya que al ser escaneado, lo detecta como MERCADONA, pero no lee lo valores correctamente. Por eso no es considerado dentro de los df's correspodientes.


```{r}
#x <- lista_nombres_ficheros[2]
x <- '20240323 Mercadona 234,20.pdf'
# <- "ticket3.pdf"

verifica <- EsMercadona(x)
verifica

lineas <- verifica[[2]]
lineas

r <- RegistroFicheros(Nombrepdf = x,NoLeido, FicheroLeido, Tienda)
NoLeido <- r$NoLeido
FicheroLeido <- r$FicheroLeido
Tienda <- r$TiendaLeida


```

# Información de los productos.

Una vez que ya tenemos detectados los ficheros con los que vamos a trabajar, vamos a extraer la información correspondiente a los diferentes tipos de productos. 

```{r}
# Como sabemos que los poductos se describen desde el encabezado 'descripcion', hasta el primer 'TOTAL', 
# buscamos la linea que contenga esa palabra. Por lo tanto:

lineas <- EsMercadona(x)[[2]]
lineas

indice_encabezado <- grep(x=lineas, pattern='Descripción')[1]
indice_total <- grep(x=lineas, pattern='TOTAL')[1]

# Leemos los productos, que van desde una linea despues del encabezado descripcion, hasta una linea menos del primer total. 

productos <- lineas[(indice_encabezado+1):(indice_total-1)]
productos <- str_replace_all(productos, "\\s+", " ") # Eliminamos los espacios multiples
productos

```

Ya tenemos identificados los productos. Ahora sigue determinar:

1. Si tiene parking o no
2. Qué tipo de producto es

```{r}
# Sabemos que disponemos de 3 tipos de productos
tipo_producto <- c('Unitario', 'Pescado', 'Fruta y verdura')

# Los productos al peso, como pescado, frutas y verduras están al final. Sabiendo que pescado está en primer lugar, podemos hacer un primer filtro. 

# Extraer los valores de cada linea con el formato de cantidad, descripcion, preciounitario, importe. 
# - ^([0-9]+) - El primer elemento, que es un número.
# - Luego de un espacio, \\s , lee cualquier caracter, excepto salto de linea (.+?)
# - Luego de otro espacio, \\s , lee el valor unitario ([0-9]+,[0-9]{2})
# - Luego de otro espacio, \\s , lee el importe total ([0-9]+,[0-9]{2})$, indicando que es el final de la linea. 

# Formato normal, para productos unitarios con mas de una unidad
patron_normal <- "^([0-9]+)\\s(.+?)\\s([0-9]+,[0-9]{2})\\s+([0-9]+,[0-9]{2})$"

# Caso 2: Cuando cantidad es 1. Es decir, sin precio unitario
patron_cantidad_1 <- "^1\\s(.+?)\\s+([0-9]+,[0-9]{2})$"

# Caso 3: Productos por peso, tanto pescado como fruteria.
patron_pescado <- "^[A-ZÁÉÍÓÚÑ]+(?:\\s+[A-ZÁÉÍÓÚÑ]+)*$"
patron_peso <- "^([0-9]+)\\s(.+)$"
patron_precio_peso <- "^([0-9,]+)\\s*kg\\s*([0-9,]+)\\s*€/kg\\s*([0-9,]+)$"

```

# Aplicamos filtros para saber el tipo de producto.

```{r}
# Como parking está al final del todo, es el filtro que aplicamos primero.
DetectaParking <- function(ListaProductos){
  
  parking <- FALSE
  
  if (any(grepl(x=ListaProductos, pattern='PARKING'))) {
    parking <- TRUE
    indice_parking <- grep(x=ListaProductos, pattern='PARKING')
    ListaProductos <- ListaProductos[1:(indice_parking-1)]
  }
  valores <- list(ListaProductos, parking)
  return(valores)
}

```


```{r}
DetectaParking(productos)[[2]] # Valor bool para saber si tiene parking o no
DetectaParking(productos)[[1]] # Lista de productos con el parking descartado
```

Dato que tenemos orden de productos: 

1. Unitario
2. Pescado
3. Frutas y verduras

Aplicamos un primer filtro para los pescados y, frutas y verduras. 

```{r}
# Solo si se ha comprado pescado, servira este filtro, para diferenciar entre unitarios y por peso.

productos <- DetectaParking(productos)[[1]]
productos

Pescado <- FALSE

if (any(grepl(x=productos, pattern='PESCADO'))) {
  
  Pescado <- TRUE
  indice_pescado <- grep(x=productos, pattern='PESCADO')
  productos_peso <- productos[(indice_pescado+1):length(productos)]
  productos <- productos[0:(indice_pescado-1)]
  
}

productos_peso[1]
productos_peso[2]
str_match(productos_peso, patron_peso) 

if (Pescado) {
  
  ListaCompra <- list()
  indice <- 1 # indice de la lista para añadir los productos  
  i <- 1
  
  while (i <= length(productos_peso)){
    p <- productos_peso[i]
    
    if (grepl(x=p, pattern=patron_pescado)) {
      elemento1 <- p
      
      if (i + 1 <= length(productos_peso)){
        i <- i + 1 
        info <- productos_peso[i]
        elemento2 <- str_match(info, patron_precio_peso)[2:4]
        
        # Una vez tenemos info del producto, lo añadimos a la lista 
        
        ListaCompra[[indice]] <- list( Fecha = fecha,
                                       IdTienda = id_tienda,
                                       IdFactura = id_factura,
                                        Producto = elemento1,
                                        Cantidad = elemento2[1],
                                        PrecioUnitario = elemento2[2],
                                        Importe = elemento2[3],
                                        TipoProducto = tipo_producto[2],
                                        Parking = parking )
        indice <- indice + 1
      }
    }
    
    else if (grepl(x=p, pattern=patron_peso)) {
        
        elemento1 <- str_match(p, patron_peso)[,3]
        
        if (i + 1 <= length(productos_peso)){
          i <- i + 1 
          info <- productos_peso[i]
          elemento2 <- str_match(info, patron_precio_peso)[2:4]
          ListaCompra[[indice]] <- list(  Fecha = fecha,
                                          IdTienda = id_tienda,
                                          IdFactura = id_factura,
                                          Producto = elemento1,
                                          Cantidad = elemento2[1],
                                          PrecioUnitario = elemento2[2],
                                          Importe = elemento2[3],
                                          TipoProducto = tipo_producto[3],
                                          Parking = parking)
          indice <- indice + 1
          }
    }
    
    i <- i + 1 
    
  }
  
}

Compra <- bind_rows(Compra, bind_rows(ListaCompra))

Compra

```




# Codigo funcional para una sola factura

Lectura de un solo fichero pdf, de prueba. 

Es una factura del mercadona? 
```{r}
# Carga de los pdf 



#nombre_pdf <- 'data/ticket_dia_03_02_2025_14_10.pdf' # Factura de otro supermercado
nombre_pdf <- 'data/20240323 Mercadona 234,20.pdf' # Factura con pescado
#nombre_pdf <- 'data/20241228 Mercadona 32,50 Ôé¼.pdf'
#nombre_pdf <- 'data/20250224 Mercadona 75,48 Ôé¼.pdf' # Con Parking



pdf_completo <- pdf_text(nombre_pdf) # Extrae el texto del pdf.
lineas <- strsplit(pdf_completo, "\n")[[1]] # Divide el texto en diferentes lineas, por cada salto de linea. 

#lineas <- sub("^\\s+", "", lineas) # Eliminamos los espacios en blanco a la izq de cada linea.
lineas <- trimws(lineas) # Elimina espacios en blanco al inicio y final de cada linea.


# Verificamos que sea una factura de Mercadona.

Mercadona <- grepl('MERCADONA', lineas[1])  
Mercadona # Solo si es TRUE, debe continuar. De no ser así, es que la factura no es de Mercadona.

```

Información encabezado, FIJO. 

Solo si es una factura del Mercadona:

```{r}
# De ser una factura del mercadona (Mercadona == TRUE), continuamos...

if (Mercadona) {
  
  info_compra <- grep(paste0("\\b", 'MERCADONA', "\\b"), lineas, ignore.case = TRUE)[1]
  info_compra_final <- grep(paste0("\\b", 'FACTURA', "\\b"), lineas, ignore.case = TRUE)[1]
  
  encabezado <- lineas[info_compra:info_compra_final]
  
}

encabezado

```
Una vez que tenemos identificado el 'espacio' del encabezado, extraemos la información. 

```{r}
if (Mercadona) {
  
  direccion <- encabezado[2]
  
  # Ubicacion 
  ubicacion <- strsplit(lineas[3], split = ' ')[[1]] 
  
  CP <- ubicacion[1]
  
  municipio <- ubicacion[2]
  
  telefono <- strsplit(lineas[4], split = ': ')[[1]][2]
  
  tiempo <- strsplit(lineas[5], split = ' ')[[1]][1:2]
  
  fecha <- tiempo[1] # String de la fecha en formato dd/mm/aaaa
  fecha
  
  hora <- tiempo[2]
  hora
  
  factura <- strsplit(lineas[6], split = ": ")[[1]]
  factura <- strsplit(factura[2], split = "-")[[1]]
  
  id_tienda <- factura[1]
  id_tienda
  
  n_caja <- factura[2]
  n_caja
  
  id_factura <- factura[3]
  id_factura
  
}

# Añadimos información del fichero, si pertenece a mercadona o no.

if ((Mercadona) & (!id_factura %in% FicheroLeido$FacturaFichero)) {
  FicheroLeido <- FicheroLeido %>%
                add_row(
                  NombreFichero = nombre_pdf,
                  FacturaFichero = id_factura
                )
} else if ((!Mercadona) & ((!nombre_pdf %in% NoLeido$NombreFichero))){
    NoLeido <- NoLeido %>%
                add_row(
                  NombreFichero = nombre_pdf
                )
}

# La información leida anteriormente, la concatenaremos en el df anteriormente creado. 
# Solo si el id_tienda no está.

info_tienda <- c(id_tienda, direccion, CP, municipio, telefono)
info_tienda

if ((Mercadona) & (!id_tienda %in% Tienda$IdTienda)){
  Tienda <- Tienda %>%
                add_row(
                  IdTienda = id_tienda,
                  Direccion = direccion,
                  CodigoPostal = CP,
                  Municipio = municipio,
                  Telefono = telefono
    )
}

```
NOTA: Automatizar para que lea cada fichero de la carpeta y almacene la información en los dataframes correspondientes. Corregir para que en nombre del fichero no aparezca 'data/'.


# Información de los productos.
```{r}
# Como sabemos que los poductos se describen desde el encabezado 'descripcion', hasta el primer 'TOTAL', buscamos la linea que contenga esa palabra. Por lo tanto:

indice_encabezado <- grep(paste0("\\b", 'Descripción', "\\b"), lineas, ignore.case = TRUE)[1]
indice_total <- grep(paste0("\\b", 'TOTAL', "\\b"), lineas, ignore.case = TRUE)[1]

# Leemos los productos, que van desde una linea despues del encabezado descripcion, hasta una linea menos del primer total. 

productos <- lineas[(indice_encabezado+1):(indice_total-1)]
productos <- str_replace_all(productos, "\\s+", " ") # Eliminamos los espacios multiples
productos

```

# Identificamos el patron de los diferentes productos, ya que pueden ser de tipo unitario, o por peso.
```{r}
# Sabemos que disponemos de 3 tipos de productos
tipo_producto <- c('Unitario', 'Pescado', 'Fruta y verdura')

# Los productos al peso, como pescado, frutas y verduras están al final. Sabiendo que pescado está en primer lugar, podemos hacer un primer filtro. 

# Extraer los valores de cada linea con el formato de cantidad, descripcion, preciounitario, importe. 
# - ^([0-9]+) - El primer elemento, que es un número.
# - Luego de un espacio, \\s , lee cualquier caracter, excepto salto de linea (.+?)
# - Luego de otro espacio, \\s , lee el valor unitario ([0-9]+,[0-9]{2})
# - Luego de otro espacio, \\s , lee el importe total ([0-9]+,[0-9]{2})$, indicando que es el final de la linea. 

# Formato normal (cantidad > 1)
patron_normal <- "^([0-9]+)\\s(.+?)\\s([0-9]+,[0-9]{2})\\s+([0-9]+,[0-9]{2})$"

# Caso 2: Cuando cantidad es 1 (sin precio unitario)
patron_cantidad_1 <- "^1\\s(.+?)\\s+([0-9]+,[0-9]{2})$"

# Caso 3: Productos por peso, tanto pescado como fruteria.
patron_pescado <- "^[A-ZÁÉÍÓÚÑ]+(?:\\s+[A-ZÁÉÍÓÚÑ]+)*$"
patron_peso <- "^([0-9]+)\\s(.+)$"
patron_precio_peso <- "^([0-9,]+)\\s*kg\\s*([0-9,]+)\\s*€/kg\\s*([0-9,]+)$"

```

# Aplicamos los diferentes filtros para determinar el tipo de producto.

```{r}
# FORMATO

# Unitarios
# Pescado
# Futeria
# Parking

# Como sabemos que parking solo estará en las ultimas dos lineas, lo descartamos primero. 
# Con esto sabemos si tiene parking. 

parking <- FALSE

if (any(grepl(paste0("\\b", 'PARKING', "\\b"), productos, ignore.case = TRUE))) {
  parking <- TRUE
  indice_parking <- grep(paste0("\\b", 'PARKING', "\\b"), productos, ignore.case = TRUE)[1]
  productos <- productos[1:(indice_parking-1)]
}

productos

```


```{r}
# Solo si se ha comprado pescado, servira este filtro, para diferenciar entre unitarios y por peso.

Peso <- FALSE

if (any(grepl('\\bPESCADO\\b', productos, ignore.case = TRUE))) {
  Peso <- TRUE
  indice_pescado <- grep("\\bPESCADO\\b", productos, ignore.case = TRUE)[1]
  productos_peso <- productos[(indice_pescado+1):length(productos)]
  productos <- productos[0:(indice_pescado-1)]
} 

productos
productos_peso

```

# Tratamos productos por peso
```{r}
# En caso de haber productos por peso, identificamos:

if (Peso) {
  
  ListaCompra <- list()
  indice <- 1 # indice de la lista para añadir los productos  
  i <- 1
  
  while (i <= length(productos_peso)){
    p <- productos_peso[i]
    
    if (grepl(patron_pescado, p)) {
      elemento1 <- p
      
      if (i + 1 <= length(productos_peso)){
        i <- i + 1 
        info <- productos_peso[i]
        elemento2 <- str_match(info, patron_precio_peso)[2:4]
        
        # Una vez tenemos info del producto, lo añadimos a la lista 
        
        ListaCompra[[indice]] <- list( Fecha = fecha,
                                       IdTienda = id_tienda,
                                       IdFactura = id_factura,
                                        Producto = elemento1,
                                        Cantidad = elemento2[1],
                                        PrecioUnitario = elemento2[2],
                                        Importe = elemento2[3],
                                        TipoProducto = tipo_producto[2],
                                        Parking = parking )
        indice <- indice + 1
      }
    }
    
    else if (grepl(patron_peso, p)) {
        
        elemento1 <- str_match(p, patron_peso)[,3]
        
        if (i + 1 <= length(productos_peso)){
          i <- i + 1 
          info <- productos_peso[i]
          elemento2 <- str_match(info, patron_precio_peso)[2:4]
          ListaCompra[[indice]] <- list(  Fecha = fecha,
                                          IdTienda = id_tienda,
                                          IdFactura = id_factura,
                                          Producto = elemento1,
                                          Cantidad = elemento2[1],
                                          PrecioUnitario = elemento2[2],
                                          Importe = elemento2[3],
                                          TipoProducto = tipo_producto[3],
                                          Parking = parking)
          indice <- indice + 1
          }
    }
    
    i <- i + 1 
    
  }
  
}

Compra <- bind_rows(Compra, bind_rows(ListaCompra))

Compra

```

# Tratamos productos por unidad

'```{r,}

i <- 1

while (i <= length(productos)){
  p <- productos[i]
  
  if ((grepl(patron_normal, p)) | (grepl(patron_cantidad_1, p))) {
    
    if (str_detect(p, patron_normal)) {
      elementos <- str_match(p, patron_normal)[,2:5]
      resultado <- data.frame( cantidad = as.numeric(elementos[1]),
                                descripcion = elementos[2],
                                precio_unit = as.numeric(str_replace(elementos[3], ",", ".")),
                                importe = as.numeric(str_replace(elementos[4], ",", ".")),
                                stringsAsFactors = FALSE )
      
    }
    else if (str_detect(p, patron_cantidad_1)) {
      elementos <- str_match(p, patron_cantidad_1)[,2:3]
      precio_total <- as.numeric(str_replace(elementos[2], ",", "."))
      resultado <- data.frame( cantidad = 1,
                                descripcion = elementos[1],
                                precio_unit = precio_total,
                                importe = precio_total,
                                stringsAsFactors = FALSE)
    }
    
    # Agregar al data frame compra
    compra <- rbind(compra, resultado)
    
  }
  
  else if (str_detect(p, patron_peso)){
    
    elemento1 <- str_match(p, patron_peso)[,3]
    
    # Verificar que existe siguiente línea
    if (i + 1 <= length(productos)) {
      i <- i + 1 # Salto para leer la siguiente linea
      peso <- productos[i]
      elemento2 <- str_match(peso, patron_precio_peso)[2:4]
      resultado <- data.frame( cantidad = elemento2[1],
                                descripcion = elemento1,
                                precio_unit = as.numeric(str_replace(elemento2[2], ",", ".")),
                                importe = as.numeric(str_replace(elemento2[3], ",", ".")),
                                stringsAsFactors = FALSE )

      # Agregar al data frame compra
      compra <- rbind(compra, resultado)
    }
  }
  i <- i + 1
}

### NOTA: HAce falta revisar los productos con pescado, y las facturas que tienen parking. 
###       También, revisar por qué se están duplicando los valores en estos bucles; 
###       mejorar para dejar con una función, a la que se le pase una línea
###       y por cada linea que lea, la añada al dataframe. 


```'''